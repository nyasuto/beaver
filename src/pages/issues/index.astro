---
/**
 * Issues List Page
 *
 * This page displays a list of GitHub issues with filtering and search capabilities.
 * Data is loaded from static JSON files generated by scripts/fetch-github-data.ts
 */

import PageLayout from '../../components/layouts/PageLayout.astro';
import PageHeader from '../../components/ui/PageHeader.astro';
import {
  getIssuesOnlyWithFallback,
  getStaticMetadata,
  hasStaticData,
  getLastUpdated,
} from '../../lib/data/github';
import { resolveUrl } from '../../lib/utils/url';
import { getFilterOptions } from '../../lib/utils/search';

const title = 'Issue';
const description = 'AIÊê≠Ëºâ„ÅÆÊ¥ûÂØü„ÅßGitHub„ÅÆIssue„ÇíÈñ≤Ë¶ß„ÉªÂàÜÊûê';

// ÈùôÁöÑ„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„ÅøÔºàPR„ÇíÈô§Â§ñ„Åó„Åüissue„ÅÆ„ÅøÔºâ
const allIssues = getIssuesOnlyWithFallback();
let metadata = null;
let lastUpdated = null;
let isDataAvailable = hasStaticData();

try {
  if (isDataAvailable) {
    metadata = getStaticMetadata();
    lastUpdated = getLastUpdated();
  }
} catch (error) {
  // eslint-disable-next-line no-console
  console.error('„É°„Çø„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
  isDataAvailable = false;
}

// ÊúÄÊñ∞„ÅÆ Issue „ÇíÂÖàÈ†≠„Å´Ë°®Á§∫
const issues = allIssues.sort(
  (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
);

// „Éá„Éï„Ç©„É´„Éà„ÅØopen„ÅÆissue„ÅÆ„ÅøË°®Á§∫
const openIssues = issues.filter(issue => issue.state === 'open');
const closedIssues = issues.filter(issue => issue.state === 'closed');

// Ë°®Á§∫Áî®„ÅÆissuesÔºà„Éá„Éï„Ç©„É´„Éà„ÅØopen„ÅÆ„ÅøÔºâ
const displayIssues = openIssues;

// „É©„Éô„É´„ÅÆÈõÜË®àÈñ¢Êï∞Ôºà„Éï„Ç£„É´„Çø„ÉºÁä∂ÊÖã„Å´Âøú„Åò„Å¶ÂãïÁöÑ„Å´Ë®àÁÆóÔºâ
function calculateLabelCounts(issueList: typeof issues) {
  return issueList.reduce(
    (acc, issue) => {
      issue.labels.forEach(label => {
        acc[label.name] = (acc[label.name] || 0) + 1;
      });
      return acc;
    },
    {} as Record<string, number>
  );
}

// ÂàùÊúüË°®Á§∫Áî®„ÅÆ„É©„Éô„É´„Ç´„Ç¶„É≥„ÉàÔºà„Ç™„Éº„Éó„É≥Issue„ÅÆ„ÅøÔºâ
const initialLabelCounts = calculateLabelCounts(openIssues);

// „Éá„Éï„Ç©„É´„ÉàË°®Á§∫Áî®
const labelCounts = initialLabelCounts;

// „É©„Éô„É´„Çí„Ç´„ÉÜ„Ç¥„É™Âà•„Å´„Ç∞„É´„Éº„ÉóÂåñ
const labelCategories = {
  priority: [] as [string, number][],
  type: [] as [string, number][],
  other: [] as [string, number][],
};

Object.entries(labelCounts).forEach(([labelName, count]) => {
  if (labelName.startsWith('priority:')) {
    labelCategories.priority.push([labelName, count]);
  } else if (labelName.startsWith('type:')) {
    labelCategories.type.push([labelName, count]);
  } else {
    labelCategories.other.push([labelName, count]);
  }
});

// ÂêÑ„Ç´„ÉÜ„Ç¥„É™ÂÜÖ„Åß„Ç´„Ç¶„É≥„ÉàÈ†Ü„Å´„ÇΩ„Éº„Éà
labelCategories.priority.sort(([, a], [, b]) => b - a);
labelCategories.type.sort(([, a], [, b]) => b - a);
labelCategories.other.sort(([, a], [, b]) => b - a);

// „Éï„Ç£„É´„Çø„Éº„Ç™„Éó„Ç∑„Éß„É≥„ÅÆÂèñÂæó
const filterOptions = getFilterOptions(issues);
---

<PageLayout
  title={title}
  description={description}
  showHeader={true}
  showFooter={true}
  showSearch={false}
  maxWidth="7xl"
  padding="lg"
  class="page-background"
>
  <PageHeader
    title="Issue"
    description="AIÊê≠Ëºâ„ÅÆÂàÜÈ°û„Å®Ê¥ûÂØü„ÅßGitHub„ÅÆIssue„ÇíÈñ≤Ë¶ß„ÉªÂàÜÊûê"
    icon="üìã"
    metaInfo={{
      totalCount: issues.length,
      openCount: openIssues.length,
      closedCount: closedIssues.length,
      lastUpdated: lastUpdated || undefined,
      repositoryOwner: metadata?.repository?.owner,
      repositoryName: metadata?.repository?.name,
      isDataAvailable: isDataAvailable,
    }}
  />

  <div class="grid grid-cols-1 lg:grid-cols-4 gap-6 space-lg">
    <!-- Filters Sidebar -->
    <aside class="lg:col-span-1">
      <div class="card">
        <h2 class="text-lg font-semibold text-heading mb-4">„Éï„Ç£„É´„Çø„Éº</h2>
        <div class="space-y-4">
          <div>
            <label class="label">„Çπ„ÉÜ„Éº„Çø„Çπ</label>
            <select class="input" id="status-filter">
              <option value="open" selected>„Ç™„Éº„Éó„É≥ ({openIssues.length})</option>
              <option value="closed">„ÇØ„É≠„Éº„Ç∫ ({closedIssues.length})</option>
              <option value="all">„Åô„Åπ„Å¶ ({issues.length})</option>
            </select>
          </div>

          <div>
            <label class="label">„É©„Éô„É´</label>
            <div class="space-y-3 max-h-64 overflow-y-auto" id="label-filters">
              <!-- ÂÑ™ÂÖàÂ∫¶„Éï„Ç£„É´„Çø„Éº -->
              {
                labelCategories.priority.length > 0 && (
                  <div>
                    <h4 class="text-xs font-semibold text-gray-600 dark:text-gray-400 mb-2 uppercase tracking-wide">
                      ÂÑ™ÂÖàÂ∫¶
                    </h4>
                    <div class="space-y-1 pl-2">
                      {labelCategories.priority.map(([labelName, count]) => (
                        <label class="flex items-center">
                          <input
                            type="checkbox"
                            class="mr-2 label-filter"
                            value={labelName}
                            data-category="priority"
                          />
                          <span class="text-sm flex-1">
                            {labelName.replace('priority:', '').trim()}
                          </span>
                          <span class="text-xs text-muted">({count})</span>
                        </label>
                      ))}
                    </div>
                  </div>
                )
              }

              <!-- „Çø„Ç§„Éó„Éï„Ç£„É´„Çø„Éº -->
              {
                labelCategories.type.length > 0 && (
                  <div>
                    <h4 class="text-xs font-semibold text-gray-600 dark:text-gray-400 mb-2 uppercase tracking-wide">
                      „Çø„Ç§„Éó
                    </h4>
                    <div class="space-y-1 pl-2">
                      {labelCategories.type.map(([labelName, count]) => (
                        <label class="flex items-center">
                          <input
                            type="checkbox"
                            class="mr-2 label-filter"
                            value={labelName}
                            data-category="type"
                          />
                          <span class="text-sm flex-1">
                            {labelName.replace('type:', '').trim()}
                          </span>
                          <span class="text-xs text-muted">({count})</span>
                        </label>
                      ))}
                    </div>
                  </div>
                )
              }

              <!-- „Åù„ÅÆ‰ªñ„É©„Éô„É´ -->
              {
                labelCategories.other.length > 0 && (
                  <div>
                    <h4 class="text-xs font-semibold text-gray-600 dark:text-gray-400 mb-2 uppercase tracking-wide">
                      „Åù„ÅÆ‰ªñ
                    </h4>
                    <div class="space-y-1 pl-2">
                      {labelCategories.other.slice(0, 8).map(([labelName, count]) => (
                        <label class="flex items-center">
                          <input
                            type="checkbox"
                            class="mr-2 label-filter"
                            value={labelName}
                            data-category="other"
                          />
                          <span class="text-sm flex-1">{labelName}</span>
                          <span class="text-xs text-muted">({count})</span>
                        </label>
                      ))}
                    </div>
                  </div>
                )
              }
            </div>
          </div>

          <div>
            <label class="label">‰ΩúÊàêËÄÖ</label>
            <select class="input" id="author-filter">
              <option value="">„Åô„Åπ„Å¶„ÅÆ‰ΩúÊàêËÄÖ</option>
              {filterOptions.authors.map(author => <option value={author}>{author}</option>)}
            </select>
          </div>

          <div>
            <label class="label">ÊãÖÂΩìËÄÖ</label>
            <select class="input" id="assignee-filter">
              <option value="">„Åô„Åπ„Å¶„ÅÆÊãÖÂΩìËÄÖ</option>
              {
                filterOptions.assignees.map(assignee => (
                  <option value={assignee}>{assignee}</option>
                ))
              }
            </select>
          </div>

          {
            isDataAvailable && metadata && (
              <div class="pt-4 border-t">
                <h3 class="text-sm font-medium text-heading mb-2">„É™„Éù„Ç∏„Éà„É™</h3>
                <p class="text-sm text-muted">
                  {metadata.repository.owner}/{metadata.repository.name}
                </p>
              </div>
            )
          }
        </div>
      </div>
    </aside>

    <!-- Issues List -->
    <div class="lg:col-span-3">
      <div class="card">
        <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6">
          <div class="flex items-center gap-4">
            <h2 class="text-lg font-semibold text-heading">Issue‰∏ÄË¶ß</h2>
            <div class="flex items-center gap-2 text-sm text-muted" id="search-results-info">
              <span id="results-count">{displayIssues.length} ‰ª∂„ÅÆ Issue „ÇíË°®Á§∫‰∏≠</span>
              <span id="search-time" class="hidden"></span>
            </div>
          </div>
          <div class="flex flex-col sm:flex-row gap-2 mt-2 sm:mt-0">
            <div class="flex gap-2">
              <input
                type="search"
                placeholder="Issue„ÇíÊ§úÁ¥¢..."
                class="input w-64"
                id="search-input"
              />
              <button class="btn btn-secondary" id="clear-search" title="Ê§úÁ¥¢„Çí„ÇØ„É™„Ç¢">‚úï</button>
            </div>
            <select class="input" id="sort-select">
              <option value="created-desc">‰ΩúÊàêÊó•ÔºàÊñ∞„Åó„ÅÑÈ†ÜÔºâ</option>
              <option value="created-asc">‰ΩúÊàêÊó•ÔºàÂè§„ÅÑÈ†ÜÔºâ</option>
              <option value="updated-desc">Êõ¥Êñ∞Êó•ÔºàÊñ∞„Åó„ÅÑÈ†ÜÔºâ</option>
              <option value="updated-asc">Êõ¥Êñ∞Êó•ÔºàÂè§„ÅÑÈ†ÜÔºâ</option>
              <option value="number-desc">IssueÁï™Âè∑ÔºàÈôçÈ†ÜÔºâ</option>
              <option value="number-asc">IssueÁï™Âè∑ÔºàÊòáÈ†ÜÔºâ</option>
              <option value="priority-desc">ÂÑ™ÂÖàÂ∫¶ÔºàÈ´ò„ÅÑÈ†ÜÔºâ</option>
              <option value="priority-asc">ÂÑ™ÂÖàÂ∫¶Ôºà‰Ωé„ÅÑÈ†ÜÔºâ</option>
            </select>
          </div>
        </div>

        <div class="space-y-4" id="issues-container">
          {
            displayIssues.length === 0 && (
              <div class="text-center py-8">
                <p class="text-muted">
                  {isDataAvailable
                    ? 'Issue „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì'
                    : '„Éá„Éº„Çø„ÇíÂèñÂæó„Åô„Çã„Å´„ÅØ npm run fetch-data „ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ'}
                </p>
              </div>
            )
          }

          {
            displayIssues.map(issue => (
              <div
                class="p-4 border rounded-md issue-card"
                data-state={issue.state}
                data-labels={issue.labels.map(l => l.name).join(',')}
                data-author={issue.user?.login || ''}
                data-assignees={issue.assignees?.map(a => a.login).join(',') || ''}
                data-number={issue.number}
                data-created={issue.created_at}
                data-updated={issue.updated_at}
                data-title={issue.title.toLowerCase()}
                data-body={(issue.body || '').toLowerCase()}
              >
                <div class="flex justify-between items-start mb-2">
                  <div class="flex-1">
                    <h3 class="font-medium text-heading">
                      <a
                        href={resolveUrl(`/issues/${issue.number}`)}
                        class="hover:text-blue-600 issue-title"
                      >
                        {issue.title}
                      </a>
                    </h3>
                    <p class="text-sm text-muted">
                      #{issue.number} ‚Ä¢ {issue.state === 'open' ? 'üü¢' : 'üî¥'}{' '}
                      {issue.state === 'open' ? '„Ç™„Éº„Éó„É≥' : '„ÇØ„É≠„Éº„Ç∫'} ‚Ä¢
                      {issue.user?.login || 'Unknown'} ‚Ä¢
                      {new Date(issue.created_at).toLocaleDateString('ja-JP')}
                    </p>
                  </div>
                  <div class="ml-4">
                    <span
                      class={`px-2 py-1 text-xs rounded font-medium ${
                        issue.state === 'open'
                          ? 'bg-green-100 text-green-800'
                          : 'bg-gray-100 text-gray-800'
                      }`}
                    >
                      {issue.state === 'open' ? '„Ç™„Éº„Éó„É≥' : '„ÇØ„É≠„Éº„Ç∫'}
                    </span>
                  </div>
                </div>

                {issue.body && (
                  <p class="text-sm text-muted mt-2 line-clamp-3 issue-body">
                    {issue.body.substring(0, 200)}
                    {issue.body.length > 200 && '...'}
                  </p>
                )}

                {issue.labels.length > 0 && (
                  <div class="flex flex-wrap gap-1 mt-3">
                    {issue.labels.map(label => (
                      <span
                        class="px-2 py-1 text-xs rounded"
                        style={`background-color: #${label.color}20; color: #${label.color}`}
                      >
                        {label.name}
                      </span>
                    ))}
                  </div>
                )}

                <div class="flex justify-between items-center mt-3 pt-3 border-t text-xs text-muted">
                  <span>‰ΩúÊàê: {new Date(issue.created_at).toLocaleDateString('ja-JP')}</span>
                  <span>Êõ¥Êñ∞: {new Date(issue.updated_at).toLocaleDateString('ja-JP')}</span>
                </div>
              </div>
            ))
          }
        </div>

        <div class="mt-6 text-center" id="pagination-info">
          <p class="text-muted text-sm" id="pagination-text">
            {displayIssues.length} ‰ª∂„ÅÆ Issue „ÇíË°®Á§∫‰∏≠
          </p>
          <div class="mt-2 hidden" id="search-stats">
            <span class="text-xs text-muted" id="search-performance"></span>
          </div>
        </div>
      </div>
    </div>
  </div>
</PageLayout>

<style>
  .search-highlight {
    background-color: yellow;
    color: black;
    font-weight: bold;
    padding: 0 2px;
    border-radius: 2px;
  }

  .issue-card.hidden {
    display: none;
  }

  .issue-card {
    transition: opacity 0.2s ease-in-out;
  }

  .issue-card.fade-out {
    opacity: 0.3;
  }

  .search-performance {
    font-size: 11px;
    color: #6b7280;
  }

  /* „ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆ„Éá„Ç∂„Ç§„É≥ÊîπÂñÑ */
  .label-filter {
    appearance: none;
    width: 16px;
    height: 16px;
    border: 2px solid #d1d5db;
    border-radius: 3px;
    background-color: white;
    position: relative;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .label-filter:checked {
    background-color: #3b82f6;
    border-color: #3b82f6;
  }

  .label-filter:checked::after {
    content: '';
    position: absolute;
    left: 2px;
    top: -1px;
    width: 4px;
    height: 8px;
    border: solid white;
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
  }

  .label-filter:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  .label-filter:hover {
    border-color: #9ca3af;
  }

  /* „ÉÄ„Éº„ÇØ„É¢„Éº„ÉâÂØæÂøú */
  .dark .label-filter {
    border-color: #6b7280;
    background-color: #374151;
  }

  .dark .label-filter:hover {
    border-color: #9ca3af;
  }
</style>

<script>
  // Import search utilities types for TypeScript support
  interface SearchFilters {
    state?: 'open' | 'closed' | 'all';
    labelCategories?: {
      priority: string[];
      type: string[];
      other: string[];
    };
    author?: string | undefined;
    assignee?: string | undefined;
  }

  class IssueSearchManager {
    private allIssues: HTMLElement[];
    private currentFilters: SearchFilters = {
      state: 'all',
      labelCategories: { priority: [], type: [], other: [] },
    };
    private currentQuery = '';
    private currentSort = { by: 'created', order: 'desc' };
    private openLabelCounts: Record<string, number>;
    private allLabelCounts: Record<string, number>;

    constructor() {
      this.allIssues = Array.from(document.querySelectorAll('.issue-card'));
      this.currentFilters.state = 'open'; // „Éá„Éï„Ç©„É´„Éà„ÅØopen„ÅÆ„Åø

      // „É©„Éô„É´„Ç´„Ç¶„É≥„Éà„ÅÆÂàùÊúüÂåñ
      this.openLabelCounts = this.calculateLabelCountsFromDOM('open');
      this.allLabelCounts = this.calculateLabelCountsFromDOM('all');

      this.initializeEventListeners();
      this.updateLabelCounts(); // ÂàùÊúüË°®Á§∫ÊôÇ„Å´„É©„Éô„É´Êï∞„ÇíÊõ¥Êñ∞
      this.performSearch(); // ÂàùÊúü„Éï„Ç£„É´„Çø„É™„É≥„Ç∞ÂÆüË°å
    }

    private calculateLabelCountsFromDOM(state: 'open' | 'closed' | 'all'): Record<string, number> {
      const labelCounts: Record<string, number> = {};

      this.allIssues.forEach(issue => {
        const issueState = issue.getAttribute('data-state');
        if (state !== 'all' && issueState !== state) return;

        const labels = (issue.getAttribute('data-labels') || '').split(',');
        labels.forEach(label => {
          if (label.trim()) {
            labelCounts[label] = (labelCounts[label] || 0) + 1;
          }
        });
      });

      return labelCounts;
    }

    private updateLabelCounts() {
      const currentCounts =
        this.currentFilters.state === 'all'
          ? this.allLabelCounts
          : this.currentFilters.state === 'open'
            ? this.openLabelCounts
            : this.calculateLabelCountsFromDOM('closed');

      // „É©„Éô„É´Êï∞„ÅÆË°®Á§∫„ÇíÊõ¥Êñ∞
      document.querySelectorAll('.label-filter').forEach(checkbox => {
        const labelName = (checkbox as HTMLInputElement).value;
        const countElement = checkbox.parentElement?.querySelector('.text-xs.text-muted');
        if (countElement) {
          const count = currentCounts[labelName] || 0;
          countElement.textContent = `(${count})`;
        }
      });
    }

    private initializeEventListeners() {
      // Search input
      const searchInput = document.getElementById('search-input') as HTMLInputElement;
      if (searchInput) {
        let searchTimeout: ReturnType<typeof setTimeout>;
        searchInput.addEventListener('input', e => {
          clearTimeout(searchTimeout);
          searchTimeout = setTimeout(() => {
            this.currentQuery = (e.target as HTMLInputElement).value;
            this.performSearch();
          }, 300); // Debounce 300ms
        });
      }

      // Clear search button
      const clearSearch = document.getElementById('clear-search');
      if (clearSearch) {
        clearSearch.addEventListener('click', () => {
          if (searchInput) {
            searchInput.value = '';
            this.currentQuery = '';
            this.performSearch();
          }
        });
      }

      // Status filter
      const statusFilter = document.getElementById('status-filter') as HTMLSelectElement;
      if (statusFilter) {
        statusFilter.addEventListener('change', e => {
          const value = (e.target as HTMLSelectElement).value;
          this.currentFilters.state = value as 'open' | 'closed' | 'all';
          this.updateLabelCounts(); // „É©„Éô„É´Êï∞„ÇíÊõ¥Êñ∞
          this.performSearch();
        });
      }

      // Label filters - „Ç´„ÉÜ„Ç¥„É™Âà•Âá¶ÁêÜ
      const labelFilters = document.querySelectorAll('.label-filter');
      labelFilters.forEach(filter => {
        filter.addEventListener('change', () => {
          // ÂêÑ„Ç´„ÉÜ„Ç¥„É™„ÅÆÈÅ∏Êäû„Åï„Çå„Åü„É©„Éô„É´„ÇíÂèéÈõÜ
          const priorityLabels = Array.from(
            document.querySelectorAll('.label-filter[data-category="priority"]:checked')
          ).map(checkbox => (checkbox as HTMLInputElement).value);

          const typeLabels = Array.from(
            document.querySelectorAll('.label-filter[data-category="type"]:checked')
          ).map(checkbox => (checkbox as HTMLInputElement).value);

          const otherLabels = Array.from(
            document.querySelectorAll('.label-filter[data-category="other"]:checked')
          ).map(checkbox => (checkbox as HTMLInputElement).value);

          this.currentFilters.labelCategories = {
            priority: priorityLabels,
            type: typeLabels,
            other: otherLabels,
          };
          this.performSearch();
        });
      });

      // Author filter
      const authorFilter = document.getElementById('author-filter') as HTMLSelectElement;
      if (authorFilter) {
        authorFilter.addEventListener('change', e => {
          const value = (e.target as HTMLSelectElement).value;
          this.currentFilters.author = value === '' ? undefined : value;
          this.performSearch();
        });
      }

      // Assignee filter
      const assigneeFilter = document.getElementById('assignee-filter') as HTMLSelectElement;
      if (assigneeFilter) {
        assigneeFilter.addEventListener('change', e => {
          const value = (e.target as HTMLSelectElement).value;
          this.currentFilters.assignee = value === '' ? undefined : value;
          this.performSearch();
        });
      }

      // Sort dropdown
      const sortSelect = document.getElementById('sort-select') as HTMLSelectElement;
      if (sortSelect) {
        sortSelect.addEventListener('change', e => {
          const [sortBy, sortOrder] = (e.target as HTMLSelectElement).value.split('-');
          this.currentSort = {
            by: sortBy as string,
            order: sortOrder as string,
          };
          this.performSearch();
        });
      }
    }

    private performSearch() {
      const startTime = performance.now();

      // Text search
      let filteredIssues = this.allIssues.filter(issue => {
        if (!this.currentQuery.trim()) return true;

        const title = issue.getAttribute('data-title') || '';
        const body = issue.getAttribute('data-body') || '';
        const author = issue.getAttribute('data-author') || '';
        const labels = issue.getAttribute('data-labels') || '';

        const searchText = `${title} ${body} ${author} ${labels}`.toLowerCase();
        const searchTerms = this.currentQuery
          .toLowerCase()
          .split(/\s+/)
          .filter(term => term.length > 0);

        return searchTerms.every(term => searchText.includes(term));
      });

      // State filter
      if (this.currentFilters.state && this.currentFilters.state !== 'all') {
        filteredIssues = filteredIssues.filter(
          issue => issue.getAttribute('data-state') === this.currentFilters.state
        );
      }

      // Label filter - ÈöéÂ±§ÁöÑ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞Ôºà„Ç´„ÉÜ„Ç¥„É™Èñì„ÅØAND„ÄÅ„Ç´„ÉÜ„Ç¥„É™ÂÜÖ„ÅØORÔºâ
      if (this.currentFilters.labelCategories) {
        const { priority, type, other } = this.currentFilters.labelCategories;

        filteredIssues = filteredIssues.filter(issue => {
          const issueLabels = (issue.getAttribute('data-labels') || '').split(',');

          // ÂêÑ„Ç´„ÉÜ„Ç¥„É™„ÅÆÊù°‰ª∂„Çí„ÉÅ„Çß„ÉÉ„ÇØ
          const priorityMatch =
            priority.length === 0 || priority.some(label => issueLabels.includes(label));
          const typeMatch = type.length === 0 || type.some(label => issueLabels.includes(label));
          const otherMatch = other.length === 0 || other.some(label => issueLabels.includes(label));

          // „Åô„Åπ„Å¶„ÅÆ„Ç´„ÉÜ„Ç¥„É™„ÅÆÊù°‰ª∂„ÇíÊ∫Ä„Åü„ÅôÂøÖË¶Å„Åå„ÅÇ„ÇãÔºàANDÊù°‰ª∂Ôºâ
          return priorityMatch && typeMatch && otherMatch;
        });
      }

      // Author filter
      if (this.currentFilters.author) {
        filteredIssues = filteredIssues.filter(
          issue =>
            issue.getAttribute('data-author')?.toLowerCase() ===
            this.currentFilters.author?.toLowerCase()
        );
      }

      // Assignee filter
      if (this.currentFilters.assignee) {
        filteredIssues = filteredIssues.filter(issue => {
          const assignees = (issue.getAttribute('data-assignees') || '').split(',');
          return assignees.some(
            assignee => assignee.toLowerCase() === this.currentFilters.assignee?.toLowerCase()
          );
        });
      }

      // Sorting
      filteredIssues.sort((a, b) => {
        let aValue: string | number;
        let bValue: string | number;

        switch (this.currentSort.by) {
          case 'created':
            aValue = new Date(a.getAttribute('data-created') || '').getTime();
            bValue = new Date(b.getAttribute('data-created') || '').getTime();
            break;
          case 'updated':
            aValue = new Date(a.getAttribute('data-updated') || '').getTime();
            bValue = new Date(b.getAttribute('data-updated') || '').getTime();
            break;
          case 'number':
            aValue = parseInt(a.getAttribute('data-number') || '0');
            bValue = parseInt(b.getAttribute('data-number') || '0');
            break;
          case 'priority':
            aValue = this.getPriorityValue(a);
            bValue = this.getPriorityValue(b);
            break;
          default:
            return 0;
        }

        const result = aValue > bValue ? 1 : aValue < bValue ? -1 : 0;
        return this.currentSort.order === 'desc' ? -result : result;
      });

      // Update UI
      this.updateIssueDisplay(filteredIssues);
      this.highlightSearchTerms();
      this.updateResultsInfo(filteredIssues.length, performance.now() - startTime);
    }

    private getPriorityValue(issue: HTMLElement): number {
      const labels = (issue.getAttribute('data-labels') || '').toLowerCase();
      if (labels.includes('priority: critical')) return 4;
      if (labels.includes('priority: high')) return 3;
      if (labels.includes('priority: medium')) return 2;
      if (labels.includes('priority: low')) return 1;
      return 0;
    }

    private updateIssueDisplay(filteredIssues: HTMLElement[]) {
      // Hide all issues first
      this.allIssues.forEach(issue => {
        issue.classList.add('hidden');
      });

      // Show filtered issues in sorted order
      const container = document.getElementById('issues-container');
      if (container) {
        // Clear container
        const existingIssues = container.querySelectorAll('.issue-card');
        existingIssues.forEach(issue => issue.remove());

        // Add filtered issues in correct order
        filteredIssues.forEach(issue => {
          issue.classList.remove('hidden');
          container.appendChild(issue);
        });
      }
    }

    private highlightSearchTerms() {
      if (!this.currentQuery.trim()) return;

      const searchTerms = this.currentQuery
        .toLowerCase()
        .split(/\s+/)
        .filter(term => term.length > 0);

      // Highlight in titles and bodies
      document.querySelectorAll('.issue-title, .issue-body').forEach(element => {
        if (element.textContent) {
          let highlightedText = element.textContent;

          searchTerms.forEach(term => {
            const regex = new RegExp(`(${this.escapeRegExp(term)})`, 'gi');
            highlightedText = highlightedText.replace(
              regex,
              '<mark class="search-highlight">$1</mark>'
            );
          });

          element.innerHTML = highlightedText;
        }
      });
    }

    private escapeRegExp(string: string): string {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    private updateResultsInfo(count: number, searchTime: number) {
      const resultsCount = document.getElementById('results-count');
      const searchTimeElement = document.getElementById('search-time');
      const paginationText = document.getElementById('pagination-text');
      const searchStats = document.getElementById('search-stats');
      const searchPerformance = document.getElementById('search-performance');

      if (resultsCount) {
        resultsCount.textContent = `${count} ‰ª∂„ÅÆ Issue „ÇíË°®Á§∫‰∏≠`;
      }

      if (paginationText) {
        const totalIssues = this.allIssues.length;
        if (count === totalIssues) {
          paginationText.textContent = `${count} ‰ª∂„ÅÆ Issue „ÇíË°®Á§∫‰∏≠`;
        } else {
          paginationText.textContent = `${totalIssues} ‰ª∂‰∏≠ ${count} ‰ª∂„ÅÆ Issue „ÇíË°®Á§∫‰∏≠`;
        }
      }

      if (searchTimeElement && this.currentQuery.trim()) {
        searchTimeElement.textContent = `(Ê§úÁ¥¢ÊôÇÈñì: ${searchTime.toFixed(1)}ms)`;
        searchTimeElement.classList.remove('hidden');
      } else if (searchTimeElement) {
        searchTimeElement.classList.add('hidden');
      }

      if (searchStats && searchPerformance) {
        if (this.currentQuery.trim() || this.hasActiveFilters()) {
          searchPerformance.textContent = `Ê§úÁ¥¢ÂÆå‰∫Ü: ${searchTime.toFixed(1)}ms`;
          searchStats.classList.remove('hidden');
        } else {
          searchStats.classList.add('hidden');
        }
      }
    }

    private hasActiveFilters(): boolean {
      const hasLabelFilters =
        this.currentFilters.labelCategories &&
        (this.currentFilters.labelCategories.priority.length > 0 ||
          this.currentFilters.labelCategories.type.length > 0 ||
          this.currentFilters.labelCategories.other.length > 0);

      return (
        (this.currentFilters.state && this.currentFilters.state !== 'all') ||
        Boolean(hasLabelFilters) ||
        Boolean(this.currentFilters.author) ||
        Boolean(this.currentFilters.assignee)
      );
    }
  }

  // Initialize search manager when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    new IssueSearchManager();
  });
</script>
