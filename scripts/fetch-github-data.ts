#!/usr/bin/env tsx

import { config } from 'dotenv';
import { writeFileSync, readFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';
import { createGitHubClient } from '../src/lib/github/client.js';
import { GitHubIssuesService } from '../src/lib/github/issues.js';
import { GitHubPullsService } from '../src/lib/github/pulls.js';
import { GitHubConfigSchema } from '../src/lib/schemas/config.js';
import { createTestClassificationEngine } from '../src/lib/classification/engine.js';
import { z } from 'zod';

// Load environment variables from .env file (GitHub ActionsÁí∞Â¢É„Åß„ÅØ‰∏çË¶Å)
if (process.env['CI'] !== 'true') {
  config();
}

/**
 * GitHub API „Åã„Çâ„Éá„Éº„Çø„ÇíÂèñÂæó„Åó„ÄÅÈùôÁöÑ„Éï„Ç°„Ç§„É´„Å®„Åó„Å¶‰øùÂ≠ò„Åô„Çã„Çπ„ÇØ„É™„Éó„Éà
 * 
 * ‰ΩøÁî®Ê≥ï:
 * - npm run fetch-data
 * - tsx scripts/fetch-github-data.ts
 * 
 * ÂøÖË¶Å„Å™Áí∞Â¢ÉÂ§âÊï∞:
 * - GITHUB_TOKEN: GitHub Personal Access Token
 * - GITHUB_OWNER: „É™„Éù„Ç∏„Éà„É™„ÅÆ„Ç™„Éº„Éä„ÉºÂêç
 * - GITHUB_REPO: „É™„Éù„Ç∏„Éà„É™Âêç
 */

const EnvSchema = z.object({
  GITHUB_TOKEN: z.string().min(1, 'GITHUB_TOKEN is required'),
  GITHUB_OWNER: z.string().min(1, 'GITHUB_OWNER is required'),
  GITHUB_REPO: z.string().min(1, 'GITHUB_REPO is required'),
});

/**
 * Áí∞Â¢ÉÂ§âÊï∞„ÅÆÊ§úË®º
 */
function validateEnvironment() {
  const env = {
    GITHUB_TOKEN: process.env['GITHUB_TOKEN'],
    GITHUB_OWNER: process.env['GITHUB_OWNER'],
    GITHUB_REPO: process.env['GITHUB_REPO'],
  };

  try {
    return EnvSchema.parse(env);
  } catch (error) {
    console.warn('‚ö†Ô∏è Áí∞Â¢ÉÂ§âÊï∞„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì:');
    if (error instanceof z.ZodError) {
      error.issues.forEach((err) => {
        console.warn(`  - ${err.path.join('.')}: ${err.message}`);
      });
    }
    console.warn('\nGitHub „Éá„Éº„Çø„ÅÆÂèñÂæó„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô„ÄÇ');
    console.warn('ÂÆüÈöõ„ÅÆ„Éá„Éº„Çø„ÇíÂèñÂæó„Åô„Çã„Å´„ÅØ‰ª•‰∏ã„ÅÆÁí∞Â¢ÉÂ§âÊï∞„ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ:');
    console.warn('  - GITHUB_TOKEN: GitHub Personal Access Token');
    console.warn('  - GITHUB_OWNER: „É™„Éù„Ç∏„Éà„É™„ÅÆ„Ç™„Éº„Éä„ÉºÂêç');
    console.warn('  - GITHUB_REPO: „É™„Éù„Ç∏„Éà„É™Âêç');
    return null;
  }
}

/**
 * „Éá„Ç£„É¨„ÇØ„Éà„É™„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ‰ΩúÊàê
 */
function ensureDirectoryExists(dirPath: string) {
  if (!existsSync(dirPath)) {
    mkdirSync(dirPath, { recursive: true });
    console.log(`üìÅ „Éá„Ç£„É¨„ÇØ„Éà„É™„Çí‰ΩúÊàê„Åó„Åæ„Åó„Åü: ${dirPath}`);
  }
}

/**
 * „Éá„Éº„Çø„Çí JSON „Éï„Ç°„Ç§„É´„Å®„Åó„Å¶‰øùÂ≠ò
 */
function saveJsonFile(filePath: string, data: any, description: string) {
  try {
    writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf8');
    console.log(`üíæ ${description}„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü: ${filePath}`);
  } catch (error) {
    console.error(`‚ùå ${description}„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:`, error);
    throw error;
  }
}

/**
 * GitHub API „Åã„Çâ„Éá„Éº„Çø„ÇíÂèñÂæó„Åó„Å¶ÈùôÁöÑ„Éï„Ç°„Ç§„É´„Å®„Åó„Å¶‰øùÂ≠ò
 */
async function fetchAndSaveGitHubData() {
  console.log('üöÄ GitHub „Éá„Éº„Çø„ÅÆÂèñÂæó„ÇíÈñãÂßã„Åó„Åæ„Åô...');
  
  // Áí∞Â¢ÉÂ§âÊï∞„ÅÆÊ§úË®º
  const env = validateEnvironment();
  
  // Áí∞Â¢ÉÂ§âÊï∞„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
  if (!env) {
    console.log('üìã „Çµ„É≥„Éó„É´„Éá„Éº„Çø„Çí‰ΩøÁî®„Åó„Å¶„Éì„É´„Éâ„ÇíÁ∂ôÁ∂ö„Åó„Åæ„Åô„ÄÇ');
    return;
  }
  
  // GitHub Ë®≠ÂÆö„ÅÆ‰ΩúÊàê
  const config = GitHubConfigSchema.parse({
    token: env.GITHUB_TOKEN,
    owner: env.GITHUB_OWNER,
    repo: env.GITHUB_REPO,
    baseUrl: 'https://api.github.com',
  });

  try {
    // „Éá„Éº„Çø„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆ‰ΩúÊàê
    const dataDir = join(process.cwd(), 'src/data/github');
    ensureDirectoryExists(dataDir);

    // GitHub Issues „ÅÆÂèñÂæó
    console.log('üì• GitHub Issues „ÇíÂèñÂæó‰∏≠...');
    
    // GitHub „ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅÆ‰ΩúÊàê
    const clientResult = createGitHubClient(config);
    if (!clientResult.success) {
      throw new Error(`GitHub „ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅÆ‰ΩúÊàê„Å´Â§±Êïó: ${clientResult.error.message}`);
    }
    
    // Issues „Çµ„Éº„Éì„Çπ„ÅÆ‰ΩúÊàê„Å®ÂÆüË°åÔºà„Ç™„Éº„Éó„É≥Issue„ÅÆ„ÅøÔºâ
    const issuesService = new GitHubIssuesService(clientResult.data);
    
    // GraphQL API „ÇíÂÑ™ÂÖà„Åó„Å¶‰ΩøÁî®ÔºàRate LimitÂØæÁ≠ñÔºâ
    console.log('üöÄ GraphQL API „Çí‰ΩøÁî®„Åó„Å¶IssueÂèñÂæó„ÇíÊúÄÈÅ©Âåñ...');
    const optimizedIssuesResult = await issuesService.fetchIssuesOptimized(
      config.owner,
      config.repo,
      {
        state: 'open',
        per_page: 100,
        sort: 'updated',
        direction: 'desc'
      }
    );
    
    let issues;
    if (!optimizedIssuesResult.success) {
      console.warn('‚ö†Ô∏è ÊúÄÈÅ©Âåñ„Åï„Çå„ÅüAPIÂèñÂæó„Å´Â§±Êïó„ÄÅÊ®ôÊ∫ñREST API„Å´„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ...');
      
      // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÂæìÊù•„ÅÆREST API
      const openIssuesResult = await issuesService.getIssues({
        state: 'open', 
        per_page: 100,
        sort: 'updated',
        direction: 'desc'
      });
      
      if (!openIssuesResult.success) {
        throw new Error(`GitHub API „Ç®„É©„Éº (open issues): ${openIssuesResult.error.message}`);
      }
      
      console.log(`‚úÖ REST API fallback: ${openIssuesResult.data.length} ‰ª∂„ÅÆ„Ç™„Éº„Éó„É≥ Issue „ÇíÂèñÂæó„Åó„Åæ„Åó„Åü`);
      issues = openIssuesResult.data;
    } else {
      console.log(`‚úÖ GraphQL API: ${optimizedIssuesResult.data.length} ‰ª∂„ÅÆ„Ç™„Éº„Éó„É≥ Issue „ÇíÂèñÂæó„Åó„Åæ„Åó„Åü`);
      issues = optimizedIssuesResult.data;
    }

    // IssueÂàÜÈ°ûÂá¶ÁêÜ„ÇíÂÆüË°å
    console.log('ü§ñ IssueÂàÜÈ°û„Ç®„É≥„Ç∏„É≥„ÇíÈñãÂßã...');
    try {
      const classificationEngine = await createTestClassificationEngine();
      
      console.log(`üìã ${issues.length} ‰ª∂„ÅÆIssue„ÇíÂàÜÈ°û‰∏≠...`);
      const batchResult = await classificationEngine.classifyIssuesBatch(issues, {
        owner: config.owner,
        repo: config.repo
      });

      console.log(`‚úÖ IssueÂàÜÈ°ûÂÆå‰∫Ü:`);
      console.log(`   - ÂàÜÊûêÊ∏à„Åø: ${batchResult.totalAnalyzed} ‰ª∂`);
      console.log(`   - Âπ≥Âùá„Çπ„Ç≥„Ç¢: ${batchResult.averageScore.toFixed(2)}`);
      console.log(`   - Âá¶ÁêÜÊôÇÈñì: ${batchResult.processingTimeMs}ms`);
      console.log(`   - „Ç≠„É£„ÉÉ„Ç∑„É•„Éí„ÉÉ„ÉàÁéá: ${(batchResult.cacheHitRate * 100).toFixed(1)}%`);

      // ÂàÜÈ°ûÁµêÊûú„ÇíÂê´„ÇÄ„Éá„Éº„Çø„Çí‰øùÂ≠ò
      const classifiedIssues = issues.map((issue, index) => ({
        ...issue,
        classification: batchResult.tasks[index]
      }));

      saveJsonFile(
        join(dataDir, 'issues.json'),
        classifiedIssues,
        'Issues „Éá„Éº„Çø (ÂàÜÈ°ûÊ∏à„Åø)'
      );

    } catch (classificationError) {
      console.warn('‚ö†Ô∏è IssueÂàÜÈ°û„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„Åå„ÄÅÂá¶ÁêÜ„ÇíÁ∂öË°å„Åó„Åæ„Åô:', classificationError);
      
      // ÂàÜÈ°û„Å´Â§±Êïó„Åó„ÅüÂ†¥Âêà„ÅØÂÖÉ„ÅÆ„Éá„Éº„Çø„Çí‰øùÂ≠ò
      saveJsonFile(
        join(dataDir, 'issues.json'),
        issues,
        'Issues „Éá„Éº„Çø'
      );
    }

    // Pull Requests „ÅÆÂèñÂæó
    console.log('üì• GitHub Pull Requests „ÇíÂèñÂæó‰∏≠...');
    
    const pullsService = new GitHubPullsService(clientResult.data);
    
    // „Åô„Åπ„Å¶„ÅÆÁä∂ÊÖã„ÅÆPull Request„ÇíÂèñÂæóÔºàopen, closed, mergedÔºâ
    const pullsResults = await Promise.all([
      pullsService.fetchEnhancedPullRequests(config.owner, config.repo, {
        state: 'open',
        per_page: 100,
        sort: 'updated',
        direction: 'desc'
      }),
      pullsService.fetchEnhancedPullRequests(config.owner, config.repo, {
        state: 'closed',
        per_page: 100,
        sort: 'updated', 
        direction: 'desc'
      })
    ]);

    const allPulls = [];
    for (const [index, result] of pullsResults.entries()) {
      if (!result.success) {
        console.warn(`‚ö†Ô∏è Pull RequestsÂèñÂæó„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü (${index === 0 ? 'open' : 'closed'}):`, result.error.message);
        continue;
      }
      allPulls.push(...result.data);
    }

    console.log(`‚úÖ ${allPulls.length} ‰ª∂„ÅÆPull Request „ÇíÂèñÂæó„Åó„Åæ„Åó„Åü`);

    // Pull Requests „Éá„Éº„Çø„Çí‰øùÂ≠ò
    saveJsonFile(
      join(dataDir, 'pulls.json'),
      allPulls,
      'Pull Requests „Éá„Éº„Çø'
    );

    // ÂÄãÂà• Pull Request „Éï„Ç°„Ç§„É´„ÅÆ‰øùÂ≠ò
    const pullsDir = join(dataDir, 'pulls');
    ensureDirectoryExists(pullsDir);

    for (const pr of allPulls) {
      saveJsonFile(
        join(pullsDir, `${pr.number}.json`),
        pr,
        `Pull Request #${pr.number}`
      );
    }

    // ÂÄãÂà• Issue „Éï„Ç°„Ç§„É´„ÅÆ‰øùÂ≠òÔºàÂàÜÈ°ûÁµêÊûú„ÇíÂê´„ÇÄÔºâ
    const issuesDir = join(dataDir, 'issues');
    ensureDirectoryExists(issuesDir);

    // issues.json„Åã„ÇâÂàÜÈ°ûÊ∏à„Åø„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø
    let classifiedIssuesData: any[];
    try {
      classifiedIssuesData = JSON.parse(readFileSync(join(dataDir, 'issues.json'), 'utf-8'));
    } catch {
      classifiedIssuesData = issues; // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
    }

    for (const issue of classifiedIssuesData) {
      saveJsonFile(
        join(issuesDir, `${issue.number}.json`),
        issue,
        `Issue #${issue.number}`
      );
    }

    // Áµ±Ë®àÊÉÖÂ†±„ÅÆË®àÁÆó
    const openIssues = issues; // „Åô„Åπ„Å¶„Ç™„Éº„Éó„É≥Issue
    const closedIssues: typeof issues = []; // Èñâ„Åò„ÅüIssue„ÅØÂèñÂæó„Åó„Å¶„ÅÑ„Å™„ÅÑ
    const labelCounts = issues.reduce((acc, issue) => {
      issue.labels.forEach(label => {
        acc[label.name] = (acc[label.name] || 0) + 1;
      });
      return acc;
    }, {} as Record<string, number>);

    // Pull RequestsÁµ±Ë®à„ÅÆË®àÁÆó
    const openPulls = allPulls.filter(pr => pr.state === 'open');
    const closedPulls = allPulls.filter(pr => pr.state === 'closed' && !pr.merged_at);
    const mergedPulls = allPulls.filter(pr => pr.merged_at);

    // „É°„Çø„Éá„Éº„Çø„ÅÆ‰øùÂ≠ò
    const metadata = {
      lastUpdated: new Date().toISOString(),
      repository: {
        owner: config.owner,
        name: config.repo,
      },
      statistics: {
        issues: {
          total: issues.length,
          open: openIssues.length,
          closed: closedIssues.length,
        },
        pullRequests: {
          total: allPulls.length,
          open: openPulls.length,
          closed: closedPulls.length,
          merged: mergedPulls.length,
        },
        labels: Object.keys(labelCounts).length,
      },
      labelCounts,
      lastIssue: issues.length > 0 ? issues[0] : null,
      lastPullRequest: allPulls.length > 0 ? allPulls[0] : null,
    };

    saveJsonFile(
      join(dataDir, 'metadata.json'),
      metadata,
      '„É°„Çø„Éá„Éº„Çø'
    );

    // ÊàêÂäü„É°„ÉÉ„Çª„Éº„Ç∏
    console.log('\nüéâ GitHub „Éá„Éº„Çø„ÅÆÂèñÂæó„Å®‰øùÂ≠ò„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü!');
    console.log(`üìä Áµ±Ë®àÊÉÖÂ†±:`);
    console.log(`   Issues:`);
    console.log(`     - Á∑èÊï∞: ${metadata.statistics.issues.total}`);
    console.log(`     - „Ç™„Éº„Éó„É≥: ${metadata.statistics.issues.open}`);
    console.log(`     - „ÇØ„É≠„Éº„Ç∫: ${metadata.statistics.issues.closed}`);
    console.log(`   Pull Requests:`);
    console.log(`     - Á∑èÊï∞: ${metadata.statistics.pullRequests.total}`);
    console.log(`     - „Ç™„Éº„Éó„É≥: ${metadata.statistics.pullRequests.open}`);
    console.log(`     - „ÇØ„É≠„Éº„Ç∫: ${metadata.statistics.pullRequests.closed}`);
    console.log(`     - „Éû„Éº„Ç∏Ê∏à„Åø: ${metadata.statistics.pullRequests.merged}`);
    console.log(`   - „É©„Éô„É´Êï∞: ${metadata.statistics.labels}`);
    console.log(`   - ÊúÄÁµÇÊõ¥Êñ∞: ${new Date(metadata.lastUpdated).toLocaleString('ja-JP')}`);

  } catch (error) {
    console.error('‚ùå „Éá„Éº„ÇøÂèñÂæó‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:', error);
    
    // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„ÅÆË°®Á§∫
    if (error instanceof Error) {
      console.error('„Ç®„É©„ÉºË©≥Á¥∞:', error.message);
      if (error.stack) {
        console.error('„Çπ„Çø„ÉÉ„ÇØ„Éà„É¨„Éº„Çπ:', error.stack);
      }
    }
    
    process.exit(1);
  }
}

// „Çπ„ÇØ„É™„Éó„Éà„ÅÆÂÆüË°å
if (import.meta.url === `file://${process.argv[1]}`) {
  fetchAndSaveGitHubData();
}

export { fetchAndSaveGitHubData };